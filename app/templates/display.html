{% extends 'base.html' %}
{% block content %}
  <section class="panel">
    <h2>Display</h2>
    {# derive active matrix size from config passed in by the view #}
    {% set _disp = config.get('display', {}) if config is defined else {} %}
    {% set _active = _disp.get('active','ws2812') %}
    {% set _plugins = _disp.get('plugins', {}) %}
    {% set _p = _plugins.get(_active, {}) %}
    {% set MATRIX_W = (_p.get('width') if _p.get('width') is not none else (_p.get('cols') if _p.get('cols') is not none else 16)) %}
    {% set MATRIX_H = (_p.get('height') if _p.get('height') is not none else (_p.get('rows') if _p.get('rows') is not none else 16)) %}

    <p>Live mirror of the {{ MATRIX_W }}Ã—{{ MATRIX_H }} LED matrix.</p>
    <div id="led-matrix" style="margin:1rem 0; display:flex; justify-content:center; align-items:center;">
      <!-- Canvas-based renderer (much faster for large matrices) -->
      <canvas id="led-canvas" style="image-rendering: pixelated; background:#000; display:block; border-radius:6px;"></canvas>
    </div>
    <div style="display:flex;gap:1rem;align-items:center;margin-top:.5rem">
      <label for="display-brightness">Brightness</label>
      <input id="display-brightness" type="range" min="0" max="100" value="25" style="width:240px">
      <span id="display-brightness-val" style="min-width:36px;text-align:right">25%</span>
      <div style="margin-left:1rem;font-size:0.9rem;color:#666">Mode: <strong id="rotary2-mode">skip</strong></div>
      <div style="margin-left:1rem; display:flex; align-items:center; gap:.4rem; font-size:0.9rem; color:#666">
        <label for="volume-bar-duration">Volume bar timeout</label>
        <input id="volume-bar-duration" type="number" step="0.1" min="0" style="width:80px"
          value="{{ (config.get('display', {}).get('volume_bar_duration_ms', 1500) / 1000) }}">
        <span style="font-size:0.85rem;color:#999">s</span>
      </div>
      <div style="margin-left:.6rem; display:flex; align-items:center; gap:.4rem; font-size:0.9rem; color:#666">
        <label for="volume-bar-color">Bar color</label>
        <input id="volume-bar-color" type="color" value="{{ config.get('display', {}).get('volume_bar_color', '#00FF00') }}" style="width:48px;height:28px;padding:0;border:0">
        <label for="volume-bar-mode" style="margin-left:.4rem">Mode</label>
        <select id="volume-bar-mode" style="width:110px">
          <option value="overlay">Overlay</option>
          <option value="pause">Pause animations</option>
        </select>
      </div>
      <div style="margin-left:.6rem; display:flex; align-items:center; gap:.4rem; font-size:0.9rem; color:#666">
        <label for="volume-bar-preview-value">Preview vol</label>
        <input id="volume-bar-preview-value" type="number" min="0" max="100" value="50" style="width:64px">
        <button id="volume-bar-preview" style="padding:.2rem .5rem">Preview</button>
      </div>
    </div>
    <div style="margin-top:1rem;display:flex;gap:1rem;align-items:center;">
      <form id="animation-upload-form" style="display:flex;gap:.5rem;align-items:center">
  <input id="animation-file" type="file" accept=".gif,.json,application/json">
        <button type="submit">Upload</button>
      </form>
      <select id="animation-list" style="min-width:220px"></select>
      <label for="animation-speed">Speed</label>
      <input id="animation-speed" type="number" value="1.0" step="0.1" style="width:70px">
      <label for="animation-loop">Loop</label>
      <input id="animation-loop" type="checkbox" checked>
      <button id="animation-play">Play</button>
      <button id="animation-stop">Stop</button>
      <button id="animation-delete" title="Delete selected animation">Delete</button>
    </div>
  <div style="font-size:0.9rem;color:#666">Pixels update: <span id="update-mode" class="status-init">Initializing...</span>. Hardware-backed when available.</div>
  </section>

  <style>
  /* Canvas renderer styling */
  #led-canvas { max-width: 100%; height: auto; }
  </style>

  <script>
  // Build canvas-based renderer for performance on large matrices
  const MATRIX_W = {{ MATRIX_W|int }}, MATRIX_H = {{ MATRIX_H|int }};
  const matrixEl = document.getElementById('led-matrix');
  const canvas = document.getElementById('led-canvas');
  const ctx = canvas.getContext('2d');
  // choose visual scale so it fits comfortably on screen
  const MAX_SIDE_PX = 640; // maximum width/height for the rendered matrix
  const scale = Math.max(1, Math.floor(MAX_SIDE_PX / Math.max(MATRIX_W, MATRIX_H)));
  // logical canvas size is the matrix size; CSS scale makes pixels larger
  canvas.width = MATRIX_W;
  canvas.height = MATRIX_H;
  canvas.style.width = (MATRIX_W * scale) + 'px';
  canvas.style.height = (MATRIX_H * scale) + 'px';
  // disable image smoothing so scaling remains crisp
  ctx.imageSmoothingEnabled = false;

  // Reusable ImageData buffer for fast pixel writes
  let imageData = ctx.createImageData(MATRIX_W, MATRIX_H);

  function hexToRGBA(hex){
    if(!hex) return [0,0,0,255];
    const s = String(hex).replace('#','');
    if(s.length === 3){
      const r = parseInt(s[0]+s[0],16); const g = parseInt(s[1]+s[1],16); const b = parseInt(s[2]+s[2],16);
      return [r,g,b,255];
    }
    const r = parseInt(s.substring(0,2),16); const g = parseInt(s.substring(2,4),16); const b = parseInt(s.substring(4,6),16);
    return [r,g,b,255];
  }

  // Shared pixel application routine using ImageData -> putImageData
  function applyPixels(pix){
    try{
      const num = MATRIX_W * MATRIX_H;
      // clamp/normalize list
      const arr = Array.isArray(pix) ? pix : [];
      for(let i=0;i<num;i++){
        const c = arr[i] || '#000000';
        const off = i * 4;
        const rgba = hexToRGBA(c);
        imageData.data[off] = rgba[0];
        imageData.data[off+1] = rgba[1];
        imageData.data[off+2] = rgba[2];
        imageData.data[off+3] = 255;
      }
      // draw to canvas (scale happens via CSS)
      ctx.putImageData(imageData, 0, 0);
    }catch(e){/* ignore */}
  }

  function setUpdateModeText(text){
    try{
      const el = document.getElementById('update-mode');
      if(!el) return;
      el.innerText = text;
      el.classList.remove('status-push','status-poll','status-init','status-disconnected');
      if(text && text.toLowerCase().includes('push')) el.classList.add('status-push');
      else if(text && text.toLowerCase().includes('poll')) el.classList.add('status-poll');
      else if(text && text.toLowerCase().includes('disconnected')) el.classList.add('status-disconnected');
      else el.classList.add('status-init');
    }catch(e){}
  }

  async function fetchDisplay(){
    try{
      const r = await fetch('/api/display');
      if(!r.ok) return;
      const j = await r.json();
      applyPixels(j.pixels||[]);
    }catch(e){}
  }

  // Try to load a Socket.IO client recommended by the server, then initialize socket.
  async function setupSocketIO(){
    try{
      const r = await fetch('/api/socketio_client');
      if(r.ok){
        const j = await r.json();
        const src = j.cdn || '/socket.io/socket.io.js';
        await new Promise((resolve,reject)=>{
          const s = document.createElement('script');
          s.src = src;
          s.async = true;
          s.onload = ()=>resolve();
          s.onerror = ()=>reject(new Error('Failed to load socket.io client'));
          document.head.appendChild(s);
        });
      } else {
        // try fallback path
        await new Promise((resolve,reject)=>{
          const s = document.createElement('script');
          s.src = '/socket.io/socket.io.js';
          s.async = true;
          s.onload = ()=>resolve();
          s.onerror = ()=>reject(new Error('Failed to load fallback socket.io client'));
          document.head.appendChild(s);
        });
      }
      // If io is available, create socket and wire display_update
      if(typeof io !== 'undefined'){
        try{
          const socket = io();
          socket.on('connect', ()=>{ setUpdateModeText('Socket.IO (push)'); });
          socket.on('disconnect', ()=>{ setUpdateModeText('Socket.IO (disconnected)'); });
          socket.on('display_update', (data)=>{
            try{ applyPixels(data.pixels || []); }catch(e){}
          });
          // nowplaying event (no-op here but available for clients that show metadata)
          socket.on('nowplaying', (data)=>{
            try{ /* placeholder in case we want to show now-playing on display page */ }catch(e){}
          });
          // rotary2 mode updates
          socket.on('rotary2_mode', (data)=>{
            try{ document.getElementById('rotary2-mode').innerText = (data && data.mode) ? data.mode : 'skip'; }catch(e){}
          });
          // Successful socket setup
          setUpdateModeText('Socket.IO (push)');
          return true;
        }catch(e){
          return false;
        }
      }
      return false;
    }catch(e){
      return false;
    }
  }

  // Initialize: attempt socket setup; otherwise fall back to polling
  (async function(){
    setUpdateModeText('Initializing...');
    const ok = await setupSocketIO();
    if(!ok){
      // polling fallback
      setUpdateModeText('Polling (500ms)');
      setInterval(fetchDisplay, 500);
      fetchDisplay();
    } else {
      // also request an initial buffer in case server didn't emit on connect
      try{ fetchDisplay(); }catch(e){}
    }
  })();

  // Animation controls and brightness / rotary mode polling (unchanged)
  async function loadAnimations(){
    try{
      const r = await fetch('/api/animations');
      if(!r.ok) return;
      const j = await r.json();
      const list = document.getElementById('animation-list');
      list.innerHTML = '';
      (j.animations||[]).forEach(n=>{
        const opt = document.createElement('option'); opt.value = n; opt.innerText = n; list.appendChild(opt);
      });
    }catch(e){}
  }
  document.getElementById('animation-upload-form').addEventListener('submit', async (ev)=>{
    ev.preventDefault();
    const f = document.getElementById('animation-file').files[0];
    if(!f) return alert('Select a file');
    const fd = new FormData(); fd.append('file', f);
    try{
      const r = await fetch('/api/animations/upload', {method:'POST', body: fd});
      const j = await r.json();
      if(!r.ok) return alert('Upload failed: '+(j.error||r.status));
      showToast('Uploaded '+j.filename);
      await loadAnimations();
    }catch(e){ alert('Upload failed'); }
  });

  document.getElementById('animation-play').addEventListener('click', async ()=>{
    const sel = document.getElementById('animation-list');
    const name = sel.value; if(!name) return alert('Select an animation');
    const speed = Number(document.getElementById('animation-speed').value)||1.0;
    const loop = document.getElementById('animation-loop').checked;
    try{
      const r = await fetch('/api/animations/play', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name, speed, loop})});
      const j = await r.json(); if(!r.ok) return alert('Play failed: '+(j.error||r.status));
      showToast('Playing '+name);
    }catch(e){ alert('Play failed'); }
  });
  document.getElementById('animation-stop').addEventListener('click', async ()=>{
    try{
      await fetch('/api/animations/stop', {method:'POST'});
      showToast('Stopped animation');
    }catch(e){}
  });

  // Delete selected animation
  document.getElementById('animation-delete').addEventListener('click', async ()=>{
    const sel = document.getElementById('animation-list');
    const name = sel.value; if(!name) return alert('Select an animation to delete');
    if(!confirm('Delete animation "'+name+'"? This cannot be undone.')) return;
    try{
      const r = await fetch('/api/animations/delete', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name})});
      const j = await r.json();
      if(!r.ok) return alert('Delete failed: '+(j.error||r.status));
      showToast('Deleted '+name);
      await loadAnimations();
    }catch(e){ alert('Delete failed'); }
  });
  loadAnimations();

  // Brightness handling
  const briEl = document.getElementById('display-brightness');
  const briVal = document.getElementById('display-brightness-val');
  let briTimeout = null;
  async function loadBrightness(){
    try{
      const r = await fetch('/api/display/brightness');
      if(!r.ok) return;
      const j = await r.json();
      const b = typeof j.brightness === 'number'? j.brightness : 0;
      briEl.value = b;
      briVal.innerText = b + '%';
    }catch(e){}
  }
  briEl.addEventListener('input', ()=>{
    if(briTimeout) clearTimeout(briTimeout);
    briVal.innerText = briEl.value + '%';
    briTimeout = setTimeout(async ()=>{
      try{
        await fetch('/api/display/brightness', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({brightness: Number(briEl.value)})});
      }catch(e){}
    }, 150);
  });
  loadBrightness();

  // Volume bar duration handling
  const volDurEl = document.getElementById('volume-bar-duration');
  const volColorEl = document.getElementById('volume-bar-color');
  const volModeEl = document.getElementById('volume-bar-mode');
  let volDurTimeout = null;
  async function loadVolumeBarDuration(){
    try{
      const r = await fetch('/api/display/volume_bar_duration');
      if(!r.ok) return;
      const j = await r.json();
      if(typeof j.volume_bar_duration_s === 'number'){
        volDurEl.value = j.volume_bar_duration_s;
        if(typeof j.volume_bar_color === 'string' && volColorEl) volColorEl.value = j.volume_bar_color;
        if(typeof j.volume_bar_mode === 'string' && volModeEl) volModeEl.value = j.volume_bar_mode;
      }
    }catch(e){ }
  }
  function saveVolumeSettingsDebounced(){
    if(volDurTimeout) clearTimeout(volDurTimeout);
    volDurTimeout = setTimeout(async ()=>{
      try{
        const sec = Number(volDurEl.value) || 0;
        const color = volColorEl ? volColorEl.value : undefined;
        const mode = volModeEl ? volModeEl.value : undefined;
        await fetch('/api/display/volume_bar_duration', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({seconds: sec, color: color, mode: mode})});
        showToast('Saved volume bar settings');
      }catch(e){ showToast('Failed to save volume bar settings'); }
    }, 300);
  }
  volDurEl.addEventListener('input', saveVolumeSettingsDebounced);
  if(volColorEl) volColorEl.addEventListener('input', saveVolumeSettingsDebounced);
  if(volModeEl) volModeEl.addEventListener('change', saveVolumeSettingsDebounced);
  loadVolumeBarDuration();

  // Preview button handler
  const volPreviewBtn = document.getElementById('volume-bar-preview');
  const volPreviewVal = document.getElementById('volume-bar-preview-value');
  if(volPreviewBtn){
    volPreviewBtn.addEventListener('click', async ()=>{
      try{
        const sec = Number(volDurEl.value) || 0;
        const color = volColorEl ? volColorEl.value : undefined;
        const mode = volModeEl ? volModeEl.value : undefined;
        const vol = volPreviewVal ? Number(volPreviewVal.value)||0 : 50;
        const payload = { seconds: sec, color: color, mode: mode, volume: vol };
        const r = await fetch('/api/display/volume_bar_preview', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload)});
        const j = await r.json();
        if(!r.ok) return showToast('Preview failed: '+(j.error||r.status));
        showToast('Preview shown');
      }catch(e){ showToast('Preview failed'); }
    });
  }

  // Try to use Socket.IO for rotary2 mode updates; fall back to polling
  (async function(){
    const ok = await setupSocketIO();
    if(!ok){
      // polling fallback
      async function loadRotary2Mode(){
        try{ const r = await fetch('/api/rotary2/mode'); if(!r.ok) return; const j = await r.json(); document.getElementById('rotary2-mode').innerText = j.mode || 'skip'; }catch(e){}
      }
      setInterval(loadRotary2Mode, 1000);
      loadRotary2Mode();
    }
  })();
  </script>

{% endblock %}
