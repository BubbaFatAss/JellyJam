{% extends 'base.html' %}
{% block content %}
  <section class="panel">
    <h2>Display</h2>
    {# derive active matrix size from config passed in by the view #}
    {% set _disp = config.get('display', {}) if config is defined else {} %}
    {% set _active = _disp.get('active','ws2812') %}
    {% set _plugins = _disp.get('plugins', {}) %}
    {% set _p = _plugins.get(_active, {}) %}
    {% set MATRIX_W = (_p.get('width') if _p.get('width') is not none else (_p.get('cols') if _p.get('cols') is not none else 16)) %}
    {% set MATRIX_H = (_p.get('height') if _p.get('height') is not none else (_p.get('rows') if _p.get('rows') is not none else 16)) %}

    <p>Live mirror of the {{ MATRIX_W }}Ã—{{ MATRIX_H }} LED matrix.</p>
    
    <!-- Display Power Toggle -->
    <div style="background:#f9fafb;border:1px solid #e5e7eb;border-radius:8px;padding:1rem;margin-bottom:1rem;display:flex;justify-content:space-between;align-items:center;">
      <div>
        <strong style="font-size:1rem;">Display Power</strong>
        <p style="margin:0.25rem 0 0 0;color:#666;font-size:0.9rem;" id="display-status">Loading...</p>
      </div>
      <label class="switch">
        <input type="checkbox" id="display-power" disabled>
        <span class="slider"></span>
      </label>
    </div>
    
    <div id="led-matrix" style="margin:1rem 0; display:flex; justify-content:center; align-items:center;">
      <!-- Canvas-based renderer (much faster for large matrices) -->
      <canvas id="led-canvas" style="image-rendering: pixelated; background:#000; display:block; border-radius:6px;"></canvas>
    </div>
    <div style="display:flex;gap:1rem;align-items:center;margin-top:.5rem">
      <label for="display-brightness">Brightness</label>
      <input id="display-brightness" type="range" min="0" max="100" value="25" style="width:240px">
      <span id="display-brightness-val" style="min-width:36px;text-align:right">25%</span>
      <div style="margin-left:1rem;font-size:0.9rem;color:#666">Mode: <strong id="rotary2-mode">skip</strong></div>
    </div>
    <div style="margin-top:1rem;display:flex;gap:1rem;align-items:center;">
      <form id="animation-upload-form" style="display:flex;gap:.5rem;align-items:center">
  <input id="animation-file" type="file" accept=".gif,.json,application/json">
        <button type="submit">Upload</button>
      </form>
      <select id="animation-list" style="min-width:220px"></select>
      <label for="animation-speed">Speed</label>
      <input id="animation-speed" type="number" value="1.0" step="0.1" style="width:70px">
      <label for="animation-loop">Loop</label>
      <input id="animation-loop" type="checkbox" checked>
      <button id="animation-play">Play</button>
      <button id="animation-stop">Stop</button>
      <button id="animation-delete" title="Delete selected animation">Delete</button>
    </div>
  <div style="font-size:0.9rem;color:#666">Pixels update: <span id="update-mode" class="status-init">Initializing...</span>. Hardware-backed when available.</div>
  </section>

  <style>
  /* Canvas renderer styling */
  #led-canvas { max-width: 100%; height: auto; }
  
  /* Toggle Switch */
  .switch {
    position: relative;
    display: inline-block;
    width: 60px;
    height: 34px;
  }
  
  .switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }
  
  .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: .3s;
    border-radius: 34px;
  }
  
  .slider:before {
    position: absolute;
    content: "";
    height: 26px;
    width: 26px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    transition: .3s;
    border-radius: 50%;
  }
  
  input:checked + .slider {
    background: linear-gradient(90deg, var(--accent), #6fb1ff);
  }
  
  input:checked + .slider:before {
    transform: translateX(26px);
  }
  
  input:disabled + .slider {
    opacity: 0.5;
    cursor: not-allowed;
  }
  </style>

  <script>
  // Build canvas-based renderer for performance on large matrices
  const MATRIX_W = {{ MATRIX_W|int }}, MATRIX_H = {{ MATRIX_H|int }};
  const matrixEl = document.getElementById('led-matrix');
  const canvas = document.getElementById('led-canvas');
  const ctx = canvas.getContext('2d');
  // choose visual scale so it fits comfortably on screen
  const MAX_SIDE_PX = 640; // maximum width/height for the rendered matrix
  const scale = Math.max(1, Math.floor(MAX_SIDE_PX / Math.max(MATRIX_W, MATRIX_H)));
  // logical canvas size is the matrix size; CSS scale makes pixels larger
  canvas.width = MATRIX_W;
  canvas.height = MATRIX_H;
  canvas.style.width = (MATRIX_W * scale) + 'px';
  canvas.style.height = (MATRIX_H * scale) + 'px';
  // disable image smoothing so scaling remains crisp
  ctx.imageSmoothingEnabled = false;

  // Reusable ImageData buffer for fast pixel writes
  let imageData = ctx.createImageData(MATRIX_W, MATRIX_H);

  function hexToRGBA(hex){
    if(!hex) return [0,0,0,255];
    const s = String(hex).replace('#','');
    if(s.length === 3){
      const r = parseInt(s[0]+s[0],16); const g = parseInt(s[1]+s[1],16); const b = parseInt(s[2]+s[2],16);
      return [r,g,b,255];
    }
    const r = parseInt(s.substring(0,2),16); const g = parseInt(s.substring(2,4),16); const b = parseInt(s.substring(4,6),16);
    return [r,g,b,255];
  }

  // Shared pixel application routine using ImageData -> putImageData
  function applyPixels(pix){
    try{
      const num = MATRIX_W * MATRIX_H;
      // clamp/normalize list
      const arr = Array.isArray(pix) ? pix : [];
      for(let i=0;i<num;i++){
        const c = arr[i] || '#000000';
        const off = i * 4;
        const rgba = hexToRGBA(c);
        imageData.data[off] = rgba[0];
        imageData.data[off+1] = rgba[1];
        imageData.data[off+2] = rgba[2];
        imageData.data[off+3] = 255;
      }
      // draw to canvas (scale happens via CSS)
      ctx.putImageData(imageData, 0, 0);
    }catch(e){/* ignore */}
  }

  function setUpdateModeText(text){
    try{
      const el = document.getElementById('update-mode');
      if(!el) return;
      el.innerText = text;
      el.classList.remove('status-push','status-poll','status-init','status-disconnected');
      if(text && text.toLowerCase().includes('push')) el.classList.add('status-push');
      else if(text && text.toLowerCase().includes('poll')) el.classList.add('status-poll');
      else if(text && text.toLowerCase().includes('disconnected')) el.classList.add('status-disconnected');
      else el.classList.add('status-init');
    }catch(e){}
  }

  async function fetchDisplay(){
    try{
      const r = await fetch('/api/display');
      if(!r.ok) return;
      const j = await r.json();
      applyPixels(j.pixels||[]);
    }catch(e){}
  }

  // Initialize: attempt socket setup; otherwise fall back to polling
  (async function(){
    setUpdateModeText('Initializing...');
    const ok = await setupSocketIO();
    if(ok && window.jellyJamSocket){
      // Wire up display-specific Socket.IO events
      window.jellyJamSocket.on('connect', ()=>{ setUpdateModeText('Socket.IO (push)'); });
      window.jellyJamSocket.on('disconnect', ()=>{ setUpdateModeText('Socket.IO (disconnected)'); });
      window.jellyJamSocket.on('display_update', (data)=>{
        try{ applyPixels(data.pixels || []); }catch(e){}
      });
      window.jellyJamSocket.on('nowplaying', (data)=>{
        try{ /* placeholder in case we want to show now-playing on display page */ }catch(e){}
      });
      window.jellyJamSocket.on('rotary2_mode', (data)=>{
        try{ document.getElementById('rotary2-mode').innerText = (data && data.mode) ? data.mode : 'skip'; }catch(e){}
      });
      
      // Socket.IO for real-time display power/brightness updates from MQTT
      window.jellyJamSocket.on('display_power_update', function(state) {
        console.log('Received display power update from MQTT:', state);
        
        // Update power toggle without triggering events
        if (state.on !== undefined && displayPowerToggle) {
          displayPowerToggle.checked = state.on;
          updateDisplayStatus(state.on);
        }
        
        // Update brightness slider without triggering events
        if (state.brightness !== undefined && briEl) {
          briEl.value = state.brightness;
          briVal.textContent = state.brightness + '%';
        }
      });
      
      setUpdateModeText('Socket.IO (push)');
      console.log('Socket.IO display MQTT updates registered');
      // Also request an initial buffer in case server didn't emit on connect
      try{ fetchDisplay(); }catch(e){}
    }
    if(!ok){
      // polling fallback
      setUpdateModeText('Polling (500ms)');
      setInterval(fetchDisplay, 500);
      fetchDisplay();
    }
  })();

  // Animation controls and brightness / rotary mode polling (unchanged)
  async function loadAnimations(){
    try{
      const r = await fetch('/api/animations');
      if(!r.ok) return;
      const j = await r.json();
      const list = document.getElementById('animation-list');
      list.innerHTML = '';
      (j.animations||[]).forEach(n=>{
        const opt = document.createElement('option'); opt.value = n; opt.innerText = n; list.appendChild(opt);
      });
    }catch(e){}
  }
  document.getElementById('animation-upload-form').addEventListener('submit', async (ev)=>{
    ev.preventDefault();
    const f = document.getElementById('animation-file').files[0];
    if(!f) return alert('Select a file');
    const fd = new FormData(); fd.append('file', f);
    try{
      const r = await fetch('/api/animations/upload', {method:'POST', body: fd});
      const j = await r.json();
      if(!r.ok) return alert('Upload failed: '+(j.error||r.status));
      showToast('Uploaded '+j.filename);
      await loadAnimations();
    }catch(e){ alert('Upload failed'); }
  });

  document.getElementById('animation-play').addEventListener('click', async ()=>{
    const sel = document.getElementById('animation-list');
    const name = sel.value; if(!name) return alert('Select an animation');
    const speed = Number(document.getElementById('animation-speed').value)||1.0;
    const loop = document.getElementById('animation-loop').checked;
    try{
      const r = await fetch('/api/animations/play', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name, speed, loop})});
      const j = await r.json(); if(!r.ok) return alert('Play failed: '+(j.error||r.status));
      showToast('Playing '+name);
    }catch(e){ alert('Play failed'); }
  });
  document.getElementById('animation-stop').addEventListener('click', async ()=>{
    try{
      const r = await fetch('/api/animations/stop', {
        method:'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({clear: true})
      });
      const j = await r.json();
      if(!r.ok) return alert('Stop failed: '+(j.error||r.status));
      showToast('Stopped animation');
    }catch(e){ alert('Stop failed: '+e.message); }
  });

  // Delete selected animation
  document.getElementById('animation-delete').addEventListener('click', async ()=>{
    const sel = document.getElementById('animation-list');
    const name = sel.value; if(!name) return alert('Select an animation to delete');
    if(!confirm('Delete animation "'+name+'"? This cannot be undone.')) return;
    try{
      const r = await fetch('/api/animations/delete', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name})});
      const j = await r.json();
      if(!r.ok) return alert('Delete failed: '+(j.error||r.status));
      showToast('Deleted '+name);
      await loadAnimations();
    }catch(e){ alert('Delete failed'); }
  });
  loadAnimations();

  // Brightness handling
  const briEl = document.getElementById('display-brightness');
  const briVal = document.getElementById('display-brightness-val');
  let briTimeout = null;
  async function loadBrightness(){
    try{
      const r = await fetch('/api/display/brightness');
      if(!r.ok) return;
      const j = await r.json();
      const b = typeof j.brightness === 'number'? j.brightness : 0;
      briEl.value = b;
      briVal.innerText = b + '%';
    }catch(e){}
  }
  briEl.addEventListener('input', ()=>{
    if(briTimeout) clearTimeout(briTimeout);
    briVal.innerText = briEl.value + '%';
    briTimeout = setTimeout(async ()=>{
      try{
        await fetch('/api/display/brightness', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({brightness: Number(briEl.value)})});
      }catch(e){}
    }, 150);
  });
  loadBrightness();

  // Display power toggle handling
  const displayPowerToggle = document.getElementById('display-power');
  const displayStatusText = document.getElementById('display-status');
  
  async function loadDisplayPower(){
    if(!displayPowerToggle || !displayStatusText) {
      console.error('Display power elements not found');
      return;
    }
    try{
      const r = await fetch('/api/display/power');
      if(!r.ok) {
        displayStatusText.textContent = 'Error';
        return;
      }
      const j = await r.json();
      displayPowerToggle.checked = j.on || false;
      displayPowerToggle.disabled = false;
      updateDisplayStatus(j.on);
    }catch(e){
      console.error('Error loading display power:', e);
      displayStatusText.textContent = 'Error';
    }
  }
  
  function updateDisplayStatus(isOn){
    if(displayStatusText) {
      displayStatusText.textContent = isOn ? 'On' : 'Off';
      displayStatusText.style.color = isOn ? '#10b981' : '#666';
    }
  }
  
  if(displayPowerToggle) {
    displayPowerToggle.addEventListener('change', async function(){
      const isOn = this.checked;
      updateDisplayStatus(isOn);
      try{
        await fetch('/api/display/power', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({on: isOn})
        });
      }catch(e){
        console.error('Failed to update display power:', e);
      }
    });
  }
  
  // Load display power state on page load
  loadDisplayPower();

  // Try to use Socket.IO for rotary2 mode updates; fall back to polling
  (async function(){
    const ok = await setupSocketIO();
    if(!ok){
      // polling fallback
      async function loadRotary2Mode(){
        try{ const r = await fetch('/api/rotary2/mode'); if(!r.ok) return; const j = await r.json(); document.getElementById('rotary2-mode').innerText = j.mode || 'skip'; }catch(e){}
      }
      setInterval(loadRotary2Mode, 1000);
      loadRotary2Mode();
    }
  })();
  </script>

{% endblock %}
