{% extends 'base.html' %}
{% block content %}
  <section class="panel">
  <h2>Now Playing <span id="update-indicator" class="status-init">Initializing...</span></h2>
    {# derive active matrix size from config so the mini-mirror can match logical pixels #}
    {% set _disp = config.get('display', {}) if config is defined else {} %}
    {% set _active = _disp.get('active','ws2812') %}
    {% set _plugins = _disp.get('plugins', {}) %}
    {% set _p = _plugins.get(_active, {}) %}
    {% set MATRIX_W = (_p.get('width') if _p.get('width') is not none else (_p.get('cols') if _p.get('cols') is not none else 16)) %}
    {% set MATRIX_H = (_p.get('height') if _p.get('height') is not none else (_p.get('rows') if _p.get('rows') is not none else 16)) %}

    <div id="np">
      <div style="display:flex;gap:1rem;align-items:center;width:100%;">
        <img id="album-art" src="" alt="album art" style="width:120px;height:120px;object-fit:cover;border-radius:8px">
        <div style="display:flex;flex-direction:column;flex:1;gap:0.25rem;min-width:0;">
          <div style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;"><strong id="title">-</strong></div>
          <div id="artist" style="color:#666;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">-</div>
          <div id="album" style="color:#666;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">-</div>
        </div>
        <!-- Small live mirror of the display (right-aligned) -->
        <canvas id="np-led-canvas" aria-hidden="true" style="image-rendering: pixelated; background:#000; display:block; width:240px; height:240px; border-radius:8px; margin-left:12px; align-self:center;"></canvas>
      </div>
      <div style="margin-top:1rem">
        <button id="prev">⏮</button>
        <button id="playpause">⏯</button>
  <button id="stop" style="margin-left:.5rem;">⏹</button>
        <button id="next">⏭</button>
      </div>
      <div style="margin-top:1rem">
        <input id="seek" type="range" min="0" max="100" value="0" style="width:100%">
        <div><span id="pos">0:00</span> / <span id="dur">0:00</span></div>
      </div>
      <div style="margin-top:1rem">
        <label for="volume">Volume</label>
        <input id="volume" type="range" min="0" max="100" value="50" style="width:100%">
        <span id="volume-indicator" style="display:none;margin-left:.6rem;font-size:0.9rem;color:#1f8ceb;background:#e6f2ff;padding:2px 6px;border-radius:6px;vertical-align:middle">Overridden</span>
      </div>
      <div style="margin-top:1rem;display:flex;gap:.5rem;align-items:center">
        <button id="shuffle-btn" title="Toggle shuffle" class="icon-btn"><svg><use xlink:href="#icon-shuffle"></use></svg></button>
        <button id="repeat-btn" title="Toggle repeat" class="icon-btn"><svg><use xlink:href="#icon-repeat"></use></svg></button>
      </div>
    </div>
  </section>

  {# Mappings quick selector moved to Simulate page #}

  <script>
  // Now Playing logic (moved from now_playing.html)
  let polling = null;
  function setUpdateIndicator(text){ try{ const el = document.getElementById('update-indicator'); if(!el) return; el.innerText = text; el.classList.remove('status-push','status-poll','status-init','status-disconnected'); if(text && text.toLowerCase().includes('push')) el.classList.add('status-push'); else if(text && text.toLowerCase().includes('poll')) el.classList.add('status-poll'); else if(text && text.toLowerCase().includes('disconnect')) el.classList.add('status-disconnected'); else el.classList.add('status-init'); }catch(e){} }
  async function fetchNow(){
    const r = await fetch('/api/nowplaying');
    const j = await r.json();
    function valOrDash(v){ return (v === null || v === undefined || v === '' || v === -1)? '-' : v; }
    document.getElementById('title').innerText = valOrDash(j.title);
    document.getElementById('artist').innerText = valOrDash(j.artist);
    document.getElementById('album').innerText = valOrDash(j.album);
    const posRaw = j.position_ms;
    const durRaw = j.duration_ms;
    // Show dashes when values are missing or invalid (for stopped playback some backends return -1)
    if (typeof posRaw === 'number' && typeof durRaw === 'number' && durRaw > 0 && posRaw >= 0){
      document.getElementById('pos').innerText = msToTime(posRaw);
      document.getElementById('dur').innerText = msToTime(durRaw);
      const pct = Math.floor((posRaw/durRaw)*100);
      document.getElementById('seek').value = pct;
      document.getElementById('seek').disabled = false;
    } else {
      document.getElementById('pos').innerText = '-';
      document.getElementById('dur').innerText = '-';
      document.getElementById('seek').value = 0;
      document.getElementById('seek').disabled = true;
    }
  const img = (j.image_url === null || j.image_url === undefined || j.image_url === -1)? '' : j.image_url || '';
  document.getElementById('album-art').src = img || '/static/placeholder_artwork.svg';
    document.getElementById('playpause').innerText = j.playing? '⏸':'⏯';
  }
  function msToTime(ms){
    const s = Math.floor(ms/1000); const m = Math.floor(s/60); const sec = s%60; return `${m}:${sec.toString().padStart(2,'0')}`;
  }
  document.getElementById('playpause').addEventListener('click', async ()=>{
    const action = document.getElementById('playpause').innerText==='⏯'?'play':'pause';
    await fetch('/api/control',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({action})});
    setTimeout(fetchNow,300);
  });
  document.getElementById('next').addEventListener('click', async ()=>{ await fetch('/api/control',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({action:'next'})}); setTimeout(fetchNow,300); });
  document.getElementById('prev').addEventListener('click', async ()=>{ await fetch('/api/control',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({action:'previous'})}); setTimeout(fetchNow,300); });
  document.getElementById('stop').addEventListener('click', async ()=>{ await fetch('/api/control',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({action:'stop'})}); setTimeout(fetchNow,300); });
  // device selection handled on the Spotify settings page
  document.getElementById('seek').addEventListener('input', async (e)=>{
    const pct = Number(e.target.value);
    const r = await fetch('/api/nowplaying'); const j = await r.json(); const dur = j.duration_ms||0; const pos = Math.floor(dur * pct/100);
    await fetch('/api/control',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({action:'seek',position_ms:pos})});
    setTimeout(fetchNow,200);
  });
  // Try to use Socket.IO for live now-playing updates; fall back to polling.
  async function setupNowPlayingSocket(){
    try{
      const r = await fetch('/api/socketio_client');
      if(r.ok){
        const j = await r.json();
        const src = j.cdn || '/socket.io/socket.io.js';
        await new Promise((resolve,reject)=>{
          const s = document.createElement('script'); s.src = src; s.async = true;
          s.onload = ()=>resolve(); s.onerror = ()=>reject(new Error('Failed to load socket.io'));
          document.head.appendChild(s);
        });
      } else {
        // fallback
        await new Promise((resolve,reject)=>{
          const s = document.createElement('script'); s.src = '/socket.io/socket.io.js'; s.async = true;
          s.onload = ()=>resolve(); s.onerror = ()=>reject(new Error('Failed to load fallback socket.io'));
          document.head.appendChild(s);
        });
      }
      if(typeof io === 'undefined') return false;
      const socket = io();
      socket.on('connect', ()=>{
        try{ if(polling){ clearInterval(polling); polling = null; } setUpdateIndicator('Push (Socket.IO)'); }catch(e){}
        // request immediate refresh (server will also emit on connect)
        fetchNow();
      });
      socket.on('disconnect', ()=>{ try{ setUpdateIndicator('Socket disconnected'); }catch(e){} });
      socket.on('nowplaying', (data)=>{ try{ const j = data||{}; function valOrDash(v){ return (v === null || v === undefined || v === '' || v === -1)? '-' : v; } document.getElementById('title').innerText = valOrDash(j.title); document.getElementById('artist').innerText = valOrDash(j.artist); document.getElementById('album').innerText = valOrDash(j.album); const posRaw = j.position_ms; const durRaw = j.duration_ms; if (typeof posRaw === 'number' && typeof durRaw === 'number' && durRaw > 0 && posRaw >= 0){ document.getElementById('pos').innerText = msToTime(posRaw); document.getElementById('dur').innerText = msToTime(durRaw); const pct = Math.floor((posRaw/durRaw)*100); document.getElementById('seek').value = pct; document.getElementById('seek').disabled = false; } else { document.getElementById('pos').innerText = '-'; document.getElementById('dur').innerText = '-'; document.getElementById('seek').value = 0; document.getElementById('seek').disabled = true; } const img = (j.image_url === null || j.image_url === undefined || j.image_url === -1)? '' : j.image_url || ''; document.getElementById('album-art').src = img || '/static/placeholder_artwork.svg'; document.getElementById('playpause').innerText = j.playing? '⏸':'⏯'; }catch(e){}
      });
      setUpdateIndicator('Push (Socket.IO)');
      return true;
    }catch(e){ return false; }
  }

  (async function(){
    setUpdateIndicator('Initializing...');
    const ok = await setupNowPlayingSocket();
    if(!ok){ setUpdateIndicator('Polling (1s)'); polling = setInterval(fetchNow, 1000); fetchNow(); }
  })();
  // Quick mappings UI moved to the Simulate page.
  // Volume handling: load current volume and send changes
  const volEl = document.getElementById('volume');
  let volTimeout = null;
  async function loadVolume(){
    try{
      const r = await fetch('/api/volume');
      const j = await r.json();
      if(j && typeof j.volume === 'number'){
        volEl.value = j.volume;
      }
    }catch(e){ /* ignore */ }
  }
  volEl.addEventListener('input', ()=>{
    // hide the 'Overridden' indicator when the user interacts
    try{
      const ind = document.getElementById('volume-indicator');
      if(ind){ ind.style.display = 'none'; }
      if(window._jj_vol_ind_to) { clearTimeout(window._jj_vol_ind_to); window._jj_vol_ind_to = null; }
    }catch(e){}
    // debounce rapid changes
    if(volTimeout) clearTimeout(volTimeout);
    volTimeout = setTimeout(async ()=>{
      const v = Number(volEl.value);
      await fetch('/api/control', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({action:'volume', volume: v})});
    }, 150);
  });
  loadVolume();
  // Shuffle / Repeat UI wiring
  const shuffleBtn = document.getElementById('shuffle-btn');
  const repeatBtn = document.getElementById('repeat-btn');
  function setShuffleButton(enabled){
    if(enabled){ shuffleBtn.classList.add('active'); shuffleBtn.dataset.on='1'; }
    else { shuffleBtn.classList.remove('active'); shuffleBtn.dataset.on='0'; }
  }
  // repeatMode can be 'off'|'context'|'track' or a boolean (legacy)
  function setRepeatButton(repeatMode){
    let mode = 'off';
    if(typeof repeatMode === 'string') mode = repeatMode;
    else mode = repeatMode? 'context':'off';
    repeatBtn.dataset.repeatMode = mode;
    if(mode === 'off') repeatBtn.classList.remove('active'); else repeatBtn.classList.add('active');
    repeatBtn.title = `Repeat: ${mode}`;
  }
  async function loadOptions(){
    try{
      const r = await fetch('/api/options'); const j = await r.json(); const o = j.options||{};
      setShuffleButton(!!o.shuffle);
      setRepeatButton(!!o.repeat);
    }catch(e){ /* ignore */ }
  }
  shuffleBtn.addEventListener('click', async ()=>{
    const enabled = shuffleBtn.dataset.on!=='1';
    // persist
    await fetch('/api/options', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({shuffle: enabled})});
    // apply temporarily
    await fetch('/api/apply_options', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({shuffle: enabled})});
    setShuffleButton(enabled);
    showToast(enabled? 'Shuffle enabled':'Shuffle disabled');
  });
  // repeat cycles: off -> context -> track -> off
  repeatBtn.addEventListener('click', async ()=>{
    const current = repeatBtn.dataset.repeatMode || 'off';
    const order = ['off','context','track'];
    const next = order[(order.indexOf(current)+1) % order.length];
    // persist
    await fetch('/api/options', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({repeat: next})});
    // apply temporarily
    await fetch('/api/apply_options', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({repeat: next})});
    setRepeatButton(next);
    showToast(`Repeat set to ${next}`);
  });
  loadOptions();
  // device selection handled on the Spotify settings page; loadDevices removed
  </script>
  <script>
  // Mini mirror for the LED matrix on the Now Playing page
  const NP_MATRIX_W = {{ MATRIX_W|int }}, NP_MATRIX_H = {{ MATRIX_H|int }};
  (function(){
    try{
      const canvas = document.getElementById('np-led-canvas');
      if(!canvas) return;
      const ctx = canvas.getContext('2d');
      // logical size = matrix native pixels; CSS keeps visual size
      canvas.width = NP_MATRIX_W;
      canvas.height = NP_MATRIX_H;
      // choose a reasonable scale so the canvas fits the CSS box (default 240px)
      const CSS_BOX = 240; // matches the CSS width/height used in the template
      const scale = Math.max(1, Math.floor(CSS_BOX / Math.max(NP_MATRIX_W, NP_MATRIX_H)));
      canvas.style.width = (NP_MATRIX_W * scale) + 'px';
      canvas.style.height = (NP_MATRIX_H * scale) + 'px';
      ctx.imageSmoothingEnabled = false;
      let imageData = ctx.createImageData(NP_MATRIX_W, NP_MATRIX_H);

      function hexToRGBA(hex){
        if(!hex) return [0,0,0,255];
        const s = String(hex).replace('#','');
        if(s.length === 3){
          const r = parseInt(s[0]+s[0],16); const g = parseInt(s[1]+s[1],16); const b = parseInt(s[2]+s[2],16);
          return [r,g,b,255];
        }
        const r = parseInt(s.substring(0,2),16); const g = parseInt(s.substring(2,4),16); const b = parseInt(s.substring(4,6),16);
        return [r,g,b,255];
      }

      function applyNowPixels(pix){
        try{
          const num = NP_MATRIX_W * NP_MATRIX_H;
          const arr = Array.isArray(pix) ? pix : [];
          for(let i=0;i<num;i++){
            const c = arr[i] || '#000000';
            const off = i * 4;
            const rgba = hexToRGBA(c);
            imageData.data[off] = rgba[0];
            imageData.data[off+1] = rgba[1];
            imageData.data[off+2] = rgba[2];
            imageData.data[off+3] = 255;
          }
          ctx.putImageData(imageData, 0, 0);
        }catch(e){ /* ignore */ }
      }

      async function fetchNowDisplay(){
        try{
          const r = await fetch('/api/display');
          if(!r.ok) return;
          const j = await r.json();
          applyNowPixels(j.pixels||[]);
        }catch(e){ }
      }

      // Try to use Socket.IO; fall back to polling
      async function setupNPsocket(){
        try{
          const r = await fetch('/api/socketio_client');
          if(r.ok){
            const j = await r.json();
            const src = j.cdn || '/socket.io/socket.io.js';
            await new Promise((resolve,reject)=>{
              const s = document.createElement('script'); s.src = src; s.async = true;
              s.onload = ()=>resolve(); s.onerror = ()=>reject(new Error('Failed to load socket.io client'));
              document.head.appendChild(s);
            });
          } else {
            await new Promise((resolve,reject)=>{
              const s = document.createElement('script'); s.src = '/socket.io/socket.io.js'; s.async = true;
              s.onload = ()=>resolve(); s.onerror = ()=>reject(new Error('Failed to load fallback socket.io client'));
              document.head.appendChild(s);
            });
          }
          if(typeof io === 'undefined') return false;
          const socket = io();
          socket.on('connect', ()=>{ try{ setUpdateIndicator('Push (Socket.IO)'); }catch(e){} fetchNowDisplay(); });
          socket.on('disconnect', ()=>{ try{ setUpdateIndicator('Socket disconnected'); }catch(e){} });
          socket.on('display_update', (data)=>{ try{ applyNowPixels(data.pixels||[]); }catch(e){} });
          return true;
        }catch(e){ return false; }
      }

      (async function(){
        const ok = await setupNPsocket();
        if(!ok){ setUpdateIndicator('Polling (1s)'); setInterval(fetchNowDisplay, 1000); fetchNowDisplay(); }
      })();

    }catch(e){ /* ignore initialization errors */ }
  })();
  </script>
{% endblock %}
