{% extends 'base.html' %}
{% block content %}
  <section class="panel">
    <h2>Mappings</h2>
    <form id="add-mapping" method="post" action="{{ url_for('mappings') }}">
      <label>Card ID <input id="card-input" name="card_id"></label>
      <div id="add-error" role="alert" style="color:#b91c1c;display:none;margin-top:0.25rem"></div>
      <label>Type <select id="type" name="type"><option value="local">Local</option><option value="spotify">Spotify</option></select></label>
      <label>Volume override (0-100, leave blank for no override)
        <input id="volume-input" name="volume" placeholder="e.g. 75" pattern="^\s*$|^\d{1,3}$">
  <small class="help"></small>
      </label>
      <label id="playlist-label"><span id="playlist-label-text">Playlist</span>
        <select id="playlist-select" name="playlist_select"><option>Loading...</option></select>
      </label>
      <label id="playlist-manual" style="display:none"><input id="manual-path" name="manual_path" placeholder="Playlist URI or ID"></label>
      <div class="form-actions">
          <button type="submit" id="add-btn">Add Mapping</button>
        </div>
    </form>
      <form id="erase-all" method="post" action="{{ url_for('mappings_erase') }}" style="margin-top:1rem">
        <button type="submit" class="danger">Erase all mappings</button>
      </form>

    <h3>Existing mappings</h3>
    <div style="overflow-x:auto;">
      <table id="mappings-table" style="width:100%;border-collapse:collapse;">
        <thead>
          <tr style="border-bottom:2px solid #ddd;">
            <th style="text-align:left;padding:0.5rem;">Card ID</th>
            <th style="text-align:left;padding:0.5rem;">Type</th>
            <th style="text-align:left;padding:0.5rem;">Playlist</th>
            <th style="text-align:center;padding:0.5rem;">Shuffle</th>
            <th style="text-align:center;padding:0.5rem;">Repeat</th>
            <th style="text-align:center;padding:0.5rem;">Volume</th>
            <th style="text-align:right;padding:0.5rem;">Actions</th>
          </tr>
        </thead>
        <tbody id="mappings-list">
          <tr><td colspan="7" style="text-align:center;padding:1rem;">Loadingâ€¦</td></tr>
        </tbody>
      </table>
    </div>
  </section>
  <script>
  (function(){
    // Helper: validate volume input element value (allow blank) and return normalized value or null
    function validateVolumeValue(val){
      const s = (val||'').toString().trim();
      if(s==='') return null;
      if(!/^\d+$/.test(s)) return NaN;
      const n = parseInt(s,10);
      if(n < 0) return 0;
      if(n > 100) return 100;
      return n;
    }

    async function loadPlaylists(){
      const res = await fetch('/api/playlists');
      const j = await res.json();
      const sel = document.getElementById('playlist-select');
      sel.innerHTML = '';
      const pls = j.playlists || [];
      const noPlaylists = (pls.length===0);
      if(noPlaylists){
        const opt = document.createElement('option'); opt.text = '(no local playlists found)'; sel.add(opt);
      } else {
        for(const p of pls){
          const opt = document.createElement('option'); opt.value = p.path; opt.text = p.name; sel.add(opt);
        }
        const other = document.createElement('option'); other.value = '__other__'; other.text = 'Other...'; sel.add(other);
      }
      // If no playlists, disable add button for local unless manual path entered
      const addBtn = document.getElementById('add-btn');
      function updateAddState(){
        const type = document.getElementById('type').value;
        const manualVal = document.getElementById('manual-path').value.trim();
        if(type==='local' && noPlaylists && !manualVal){
          addBtn.disabled = true;
        } else addBtn.disabled = false;
      }
      document.getElementById('manual-path').addEventListener('input', updateAddState);
      document.getElementById('type').addEventListener('change', updateAddState);
      updateAddState();
    }

    document.getElementById('playlist-select').addEventListener('change', (e)=>{
      const manual = document.getElementById('playlist-manual');
      if(e.target.value==='__other__'){
        manual.style.display='block';
        document.getElementById('manual-path').value='';
      } else manual.style.display='none';
    });
    document.getElementById('type').addEventListener('change', (e)=>{
      const selLabel = document.getElementById('playlist-label');
      if(e.target.value==='spotify'){
        document.getElementById('playlist-label-text').innerText = 'Playlist URI or ID';
        document.getElementById('playlist-select').style.display='none';
        document.getElementById('playlist-manual').style.display='block';
      } else {
        document.getElementById('playlist-label-text').innerText = 'Playlist';
        document.getElementById('playlist-select').style.display='inline-block';
        document.getElementById('playlist-manual').style.display='none';
      }
    });

    // Fetch and render mappings
    async function refreshMappingsList(){
      try{
        const res = await fetch('/api/mappings');
        const j = await res.json();
        const tbody = document.getElementById('mappings-list');
        tbody.innerHTML = '';
        const list = j.mappings || [];
        if(list.length===0){ 
          const tr = document.createElement('tr');
          const td = document.createElement('td');
          td.setAttribute('colspan', '7');
          td.style.textAlign = 'center';
          td.style.padding = '1rem';
          td.innerText = 'No mappings yet';
          tr.appendChild(td);
          tbody.appendChild(tr);
          return;
        }
        for(const m of list){
          const tr = document.createElement('tr');
          tr.setAttribute('data-card-id', m.card_id);
          tr.style.borderBottom = '1px solid #eee';
          
          // Card ID column
          const tdCard = document.createElement('td');
          tdCard.style.padding = '0.5rem';
          const strong = document.createElement('strong');
          strong.innerText = m.card_id;
          tdCard.appendChild(strong);
          tr.appendChild(tdCard);
          
          // Type column
          const tdType = document.createElement('td');
          tdType.style.padding = '0.5rem';
          const spanType = document.createElement('span');
          spanType.className = 'map-type';
          spanType.innerText = m.type;
          tdType.appendChild(spanType);
          tr.appendChild(tdType);
          
          // Playlist column
          const tdPlaylist = document.createElement('td');
          tdPlaylist.style.padding = '0.5rem';
          const spanId = document.createElement('span');
          spanId.className = 'map-id';
          spanId.innerText = m.name || m.id;
          spanId.title = m.id;  // Show full path on hover
          tdPlaylist.appendChild(spanId);
          tr.appendChild(tdPlaylist);
          
          // Shuffle column
          const tdShuffle = document.createElement('td');
          tdShuffle.style.padding = '0.5rem';
          tdShuffle.style.textAlign = 'center';
          tdShuffle.innerText = m.shuffle ? 'âœ“' : 'â€”';
          tr.appendChild(tdShuffle);
          
          // Repeat column
          const tdRepeat = document.createElement('td');
          tdRepeat.style.padding = '0.5rem';
          tdRepeat.style.textAlign = 'center';
          tdRepeat.innerText = (m.repeat && m.repeat !== 'off') ? 'âœ“' : 'â€”';
          tr.appendChild(tdRepeat);
          
          // Volume column
          const tdVolume = document.createElement('td');
          tdVolume.style.padding = '0.5rem';
          tdVolume.style.textAlign = 'center';
          tdVolume.innerText = m.volume != null ? m.volume : 'â€”';
          tr.appendChild(tdVolume);
          
          // Actions column
          const tdActions = document.createElement('td');
          tdActions.style.padding = '0.5rem';
          tdActions.style.textAlign = 'right';
          tdActions.style.whiteSpace = 'nowrap';
          
          const editBtn = document.createElement('button');
          editBtn.className = 'edit-mapping small';
          editBtn.innerHTML = 'âœï¸';
          editBtn.title = 'Edit mapping';
          editBtn.style.padding = '0.25rem 0.5rem';
          editBtn.style.border = 'none';
          editBtn.style.background = 'transparent';
          editBtn.style.cursor = 'pointer';
          editBtn.style.fontSize = '1.2em';
          editBtn.addEventListener('click', ()=>{ openInlineEditor(tr, m); });
          
          const animBtn = document.createElement('button');
          animBtn.className = 'edit-animations small';
          animBtn.style.marginLeft = '0.25rem';
          animBtn.innerHTML = 'ðŸŽ¬';
          animBtn.title = 'Edit animations';
          animBtn.style.padding = '0.25rem 0.5rem';
          animBtn.style.border = 'none';
          animBtn.style.background = 'transparent';
          animBtn.style.cursor = 'pointer';
          animBtn.style.fontSize = '1.2em';
          animBtn.addEventListener('click', ()=>{ openAnimationsEditor(tr, m); });
          
          const delForm = document.createElement('form');
          delForm.method = 'post';
          delForm.action = '{{ url_for("mappings_delete") }}';
          delForm.style.display = 'inline';
          delForm.style.marginLeft = '0.25rem';
          
          const hid = document.createElement('input');
          hid.type = 'hidden';
          hid.name = 'card_id';
          hid.value = m.card_id;
          delForm.appendChild(hid);
          
          const delBtn = document.createElement('button');
          delBtn.type = 'submit';
          delBtn.className = 'small danger';
          delBtn.innerHTML = 'ðŸ—‘ï¸';
          delBtn.title = 'Delete mapping';
          delBtn.style.padding = '0.25rem 0.5rem';
          delBtn.style.border = 'none';
          delBtn.style.background = 'transparent';
          delBtn.style.cursor = 'pointer';
          delBtn.style.fontSize = '1.2em';
          delForm.appendChild(delBtn);
          
          delForm.addEventListener('submit', (ev)=>{
            if(!confirm('Delete this mapping?')) ev.preventDefault();
          });
          
          tdActions.appendChild(editBtn);
          tdActions.appendChild(animBtn);
          tdActions.appendChild(delForm);
          tr.appendChild(tdActions);
          
          tbody.appendChild(tr);
        }
      }catch(err){ console.error('Failed to refresh mappings',err); }
    }

    // Add mapping via AJAX (single-page)
    document.getElementById('add-mapping').addEventListener('submit', async (ev)=>{
      ev.preventDefault();
      const type = document.getElementById('type').value;
      const sel = document.getElementById('playlist-select');
      const manual = document.getElementById('manual-path');
      const card = document.getElementById('card-input').value.trim();
      const addErrorEl = document.getElementById('add-error'); addErrorEl.style.display='none'; addErrorEl.innerText='';
      if(!card){ addErrorEl.innerText='Card ID cannot be empty'; addErrorEl.style.display='block'; return; }
      // prepare formdata
      const fd = new FormData();
      fd.append('card_id', card);
      fd.append('type', type);
      // playlist selection
      if(type === 'spotify'){
        const v = manual.value.trim();
        if(!v){ addErrorEl.innerText='Please provide a Spotify playlist URI or ID'; addErrorEl.style.display='block'; return; }
        const uriPattern = /^(spotify:playlist:[a-zA-Z0-9]+|[A-Za-z0-9]{22,}|https:\/\/open\.spotify\.com\/playlist\/[A-Za-z0-9]+)/;
        if(!uriPattern.test(v)){
          if(!confirm('The value does not look like a Spotify URI or ID. Submit anyway?')){ return; }
        }
        fd.append('playlist_id', v);
      } else {
        if(sel.value === '__other__'){
          if(!manual.value.trim()){ addErrorEl.innerText='Please provide a path for the playlist'; addErrorEl.style.display='block'; return; }
          fd.append('playlist_id', manual.value.trim());
        } else {
          fd.append('playlist_id', sel.value);
        }
      }
      // volume
      const volEl = document.getElementById('volume-input');
      if(volEl){
        const volVal = validateVolumeValue(volEl.value);
        if(Number.isNaN(volVal)){
          addErrorEl.innerText='Volume must be an integer between 0 and 100, or left blank for no override'; addErrorEl.style.display='block'; return;
        }
        if(volVal !== null) fd.append('volume', volVal);
      }

      // submit via fetch
      try{
        const res = await fetch('{{ url_for("mappings") }}', { method: 'POST', headers: {'X-Requested-With':'XMLHttpRequest'}, body: fd });
        if(res.ok){
          try{ showToast('Mapping added', 2500); }catch(e){}
          // clear form
          document.getElementById('card-input').value = '';
          document.getElementById('manual-path').value = '';
          if(volEl) volEl.value='';
          await refreshMappingsList();
        } else {
          const txt = await res.text(); addErrorEl.innerText = 'Add failed: '+res.status; addErrorEl.style.display='block';
        }
      }catch(err){ console.error(err); alert('Network error adding mapping'); }
    });

    // Inline editor with playlist wiring
    function openInlineEditor(tr, mapping){
      const editRow = document.createElement('tr');
      editRow.className = 'edit-row';
      const editCell = document.createElement('td');
      editCell.setAttribute('colspan', '7');
      editCell.style.padding = '1rem';
      editCell.style.backgroundColor = '#f9fafb';
      
      const form = document.createElement('form');
      form.style.display = 'grid';
      form.style.gap = '0.5rem';
      form.innerHTML = `
        <input type="hidden" name="card_id" value="${mapping.card_id}">
        <label>Type <select name="type"><option value="local">Local</option><option value="spotify">Spotify</option></select></label>
        <label>Playlist <select name="playlist_id" class="inline-playlist"></select><input type="text" name="playlist_manual" class="inline-manual" style="display:none;width:100%"></label>
        <label>Shuffle <input type="checkbox" name="shuffle" ${mapping.shuffle? 'checked':''}></label>
        <label>Repeat <input type="checkbox" name="repeat" ${mapping.repeat && mapping.repeat !== 'off'? 'checked':''}></label>
        <label>Volume override (0-100, blank = no override)
          <input name="volume" placeholder="e.g. 75" value="${mapping.volume!=null?mapping.volume:''}">
          <small class="help"></small>
        </label>
        <div><span class="edit-error" style="color:#b91c1c;display:none;margin-right:1rem"></span><button type="submit">Save</button> <button type="button" class="cancel-edit">Cancel</button></div>
      `;
      
      editCell.appendChild(form);
      editRow.appendChild(editCell);
      tr.style.display = 'none';
      tr.parentNode.insertBefore(editRow, tr.nextSibling);

      const playlistSelect = form.querySelector('.inline-playlist');
      const playlistManual = form.querySelector('.inline-manual');
      // populate playlistSelect with same data as main page
      (async ()=>{
        const res = await fetch('/api/playlists');
        const j = await res.json();
        playlistSelect.innerHTML = '';
        for(const p of j.playlists || []){
          const opt = document.createElement('option'); opt.value = p.path; opt.text = p.name; playlistSelect.add(opt);
        }
        const other = document.createElement('option'); other.value='__other__'; other.text='Other...'; playlistSelect.add(other);
        // set initial value
        if(mapping.type==='local'){
          // try to select existing path
          let found = false;
          for(const o of playlistSelect.options){ if(o.value===mapping.id){ o.selected = true; found=true; break; } }
          if(!found){ playlistSelect.value='__other__'; playlistManual.style.display='block'; playlistManual.value = mapping.id || ''; }
        } else {
          // spotify mapping: show manual
          playlistSelect.style.display='none'; playlistManual.style.display='block'; playlistManual.value = mapping.id || '';
          form.querySelector('select[name="type"]').value='spotify';
        }
      })();

      form.querySelector('.cancel-edit').addEventListener('click', ()=>{ editRow.remove(); tr.style.display=''; });

      form.addEventListener('submit', async (ev)=>{
        ev.preventDefault();
        const errEl = form.querySelector('.edit-error'); errEl.style.display='none'; errEl.innerText='';
        // assemble payload
        const fd = new FormData(form);
        // if inline playlist select is visible and value is __other__, append from manual
        const ps = playlistSelect.style.display !== 'none' ? playlistSelect.value : '__manual__';
        if(ps === '__other__'){
          const manualVal = playlistManual.value.trim();
          if(!manualVal){ errEl.innerText='Please provide a playlist path/URI'; errEl.style.display='inline-block'; return; }
          fd.set('playlist_id', manualVal);
        } else if(ps === '__manual__'){
          fd.set('playlist_id', playlistManual.value.trim());
        } else {
          fd.set('playlist_id', ps);
        }
        // validate volume
        const volInput = form.querySelector('input[name="volume"]');
        if(volInput){ const v = validateVolumeValue(volInput.value); if(Number.isNaN(v)){ errEl.innerText='Volume must be an integer 0-100'; errEl.style.display='inline-block'; return; } if(v!==null) volInput.value = v; }
        try{
          const res = await fetch('{{ url_for("mappings") }}', { method: 'POST', headers: {'X-Requested-With':'XMLHttpRequest'}, body: fd });
          if(res.ok){ showToast('Mapping saved',2000); editRow.remove(); await refreshMappingsList(); } else { const txt = await res.text(); errEl.innerText='Save failed: '+res.status; errEl.style.display='inline-block'; }
        }catch(err){ console.error(err); errEl.innerText='Network error'; errEl.style.display='inline-block'; }
      });
    }

    // Animations editor: associate an animation file with individual tracks in the mapping
    async function openAnimationsEditor(tr, mapping){
      // fetch tracks, animations and existing associations
      const card = mapping.card_id;
      const tracksResp = await fetch(`/api/mappings/${encodeURIComponent(card)}/tracks`);
      const tracksJson = await tracksResp.json();
      const tracks = tracksJson.tracks || [];
      const animResp = await fetch('/api/animations');
      const animJson = await animResp.json();
      const anims = animJson.animations || [];
      const assocResp = await fetch(`/api/mappings/${encodeURIComponent(card)}/animations`);
      const assocJson = await assocResp.json();
      const existing = assocJson.animations || {};

      // build editor UI
      const panel = document.createElement('div'); panel.className='panel';
      const title = document.createElement('h4'); title.innerText = `Animations for ${card}`;
      panel.appendChild(title);
      const table = document.createElement('table'); table.style.width='100%';
      const thead = document.createElement('thead'); thead.innerHTML = '<tr><th>Track</th><th>Animation</th><th>Loop</th></tr>'; table.appendChild(thead);
      const tbody = document.createElement('tbody');
        for(const t of tracks){
        const tr = document.createElement('tr');
        const tdTrack = document.createElement('td'); tdTrack.innerText = t.title || t.id;
        const tdAnim = document.createElement('td');
        const sel = document.createElement('select'); sel.style.width='100%';
  const noneOpt = document.createElement('option'); noneOpt.value=''; noneOpt.text = '(none)'; sel.add(noneOpt);
  // special option to stop/clear the display
  const stopOpt = document.createElement('option'); stopOpt.value='__STOP__'; stopOpt.text = '(Stop / Clear display)'; sel.add(stopOpt);
  for(const a of anims){ const o = document.createElement('option'); o.value=a; o.text=a; sel.add(o); }
        // preselect existing
        const cur = existing[t.id];
        if(cur && cur.animation){ sel.value = cur.animation; }
        tdAnim.appendChild(sel);
        const tdLoop = document.createElement('td');
        const chk = document.createElement('input'); chk.type='checkbox'; chk.checked = cur && cur.loop;
        tdLoop.appendChild(chk);
        // preview button
        const tdPreview = document.createElement('td');
        const previewBtn = document.createElement('button'); previewBtn.type='button'; previewBtn.className='small'; previewBtn.innerText='Preview';
        previewBtn.addEventListener('click', async ()=>{
          const animName = sel.value;
          const loopNow = !!chk.checked;
          if(!animName){ alert('No animation selected for preview'); return; }
          try{
            if(animName === '__STOP__'){
              // request server to stop animation and clear display
              const r = await fetch('/api/animations/stop', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({clear: true}) });
              if(r.ok){ try{ showToast('Display cleared', 1500); }catch(e){} } else { alert('Failed to clear display'); }
              return;
            }
            const r = await fetch('/api/animations/play', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({name: animName, loop: loopNow, speed: 1.0}) });
            if(r.ok){ try{ showToast('Preview started', 1500); }catch(e){} } else { const txt = await r.text(); alert('Preview failed: '+r.status); }
          }catch(err){ console.error(err); alert('Network error starting preview'); }
        });
        tdPreview.appendChild(previewBtn);
        tr.appendChild(tdTrack); tr.appendChild(tdAnim); tr.appendChild(tdLoop); tr.appendChild(tdPreview);
        // store track id on row for save
        tr.dataset.trackId = t.id;
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      panel.appendChild(table);
      const btnBar = document.createElement('div'); btnBar.style.marginTop='0.5rem';
      const saveBtn = document.createElement('button'); saveBtn.innerText='Save';
      const cancelBtn = document.createElement('button'); cancelBtn.innerText='Cancel'; cancelBtn.style.marginLeft='0.5rem';
      btnBar.appendChild(saveBtn); btnBar.appendChild(cancelBtn); panel.appendChild(btnBar);
      
      // insert after table row
      const animRow = document.createElement('tr');
      const animCell = document.createElement('td');
      animCell.setAttribute('colspan', '7');
      animCell.style.padding = '0';
      animCell.appendChild(panel);
      animRow.appendChild(animCell);
      tr.style.display='none';
      tr.parentNode.insertBefore(animRow, tr.nextSibling);

      cancelBtn.addEventListener('click', ()=>{ animRow.remove(); tr.style.display=''; });

      saveBtn.addEventListener('click', async ()=>{
        // collect associations
        const associations = {};
        for(const row of tbody.querySelectorAll('tr')){
          const tid = row.dataset.trackId;
          const sel = row.querySelector('select');
          const chk = row.querySelector('input[type=checkbox]');
          const anim = sel.value || null;
          if(anim === null){
            // remove mapping if present
            associations[tid] = null;
          } else {
            associations[tid] = { animation: anim, loop: !!chk.checked };
          }
        }
        try{
          const r = await fetch(`/api/mappings/${encodeURIComponent(card)}/animations`, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({associations}) });
          if(r.ok){ showToast('Animations saved',2000); animRow.remove(); await refreshMappingsList(); } else { alert('Save failed'); }
        }catch(err){ console.error(err); alert('Network error'); }
      });
    }

    // bind page actions
    document.getElementById('erase-all').addEventListener('submit', (ev)=>{ if(!confirm('Erase ALL mappings? This cannot be undone.')) ev.preventDefault(); });

    // initial load
    loadPlaylists();
    refreshMappingsList();
  })();
  </script>
  {% endblock %}
